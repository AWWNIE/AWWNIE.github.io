<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>WatchTogether</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
  <script src="https://www.youtube.com/iframe_api"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body { 
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background: linear-gradient(135deg, #0f0f0f 0%, #1a1a1a 100%);
      color: #ffffff;
      min-height: 100vh;
      overflow-x: hidden;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }

    .header {
      text-align: center;
      margin-bottom: 30px;
    }

    .header h1 {
      font-size: 3rem;
      font-weight: 700;
      color: #667eea;
      margin-bottom: 10px;
    }

    .header p {
      color: #888;
      font-size: 1.1rem;
      margin-bottom: 15px;
    }

    .platform-info {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }

    .platform-badge {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      font-size: 12px;
      color: #aaa;
    }

    .platform-icon {
      width: 16px;
      height: 16px;
      border-radius: 50%;
    }

    .youtube { background: #ff0000; }
    .anime { background: #4ecdc4; }
    .vimeo { background: #1ab7ea; }
    .twitch { background: #9146ff; }

    .stats-display {
      display: flex;
      justify-content: center;
      gap: 30px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }

    .stat-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 15px 20px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      backdrop-filter: blur(10px);
      min-width: 120px;
    }

    .stat-number {
      font-size: 2rem;
      font-weight: 700;
      color: #667eea;
      margin-bottom: 5px;
    }

    .stat-label {
      color: #aaa;
      font-size: 0.9rem;
      font-weight: 500;
    }

    .login-section {
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 20px;
      padding: 40px;
      text-align: center;
      max-width: 500px;
      margin: 0 auto;
    }

    .app-section {
      display: none;
    }

    .main-content {
      display: flex;
      flex-direction: column;
      gap: 30px;
      margin-bottom: 30px;
    }

    .video-section {
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 20px;
      padding: 25px;
      backdrop-filter: blur(10px);
      order: 1;
    }

    .queue-section {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 20px;
      padding: 25px;
      backdrop-filter: blur(10px);
      order: 2;
    }

    .users-section {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 20px;
      padding: 25px;
      backdrop-filter: blur(10px);
      order: 3;
    }

    .users-toggle {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 20px;
      cursor: pointer;
      padding: 10px 15px;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.05);
      transition: all 0.3s ease;
    }

    .users-toggle:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .users-content {
      transition: all 0.3s ease;
      overflow: hidden;
    }

    .users-content.collapsed {
      max-height: 0;
      opacity: 0;
      margin-top: 0;
    }

    .users-content.expanded {
      max-height: 500px;
      opacity: 1;
      margin-top: 0;
    }

    .toggle-icon {
      transition: transform 0.3s ease;
      font-size: 1.2rem;
    }

    .toggle-icon.rotated {
      transform: rotate(180deg);
    }

    .current-video {
      text-align: center;
      margin-bottom: 25px;
    }

    .current-video h2 {
      font-size: 1.4rem;
      margin-bottom: 10px;
      color: #fff;
      font-weight: 600;
    }

    .video-title {
      color: #888;
      font-size: 0.9rem;
      margin-bottom: 15px;
      line-height: 1.4;
    }

    .sync-indicator {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      background: rgba(16, 172, 132, 0.2);
      border: 1px solid rgba(16, 172, 132, 0.3);
      border-radius: 12px;
      font-size: 12px;
      font-weight: 500;
      color: #10ac84;
      margin-bottom: 15px;
    }

    .sync-indicator.syncing {
      background: rgba(255, 165, 0, 0.2);
      border-color: rgba(255, 165, 0, 0.3);
      color: #ffa500;
    }

    .sync-indicator.out-of-sync {
      background: rgba(255, 107, 107, 0.2);
      border-color: rgba(255, 107, 107, 0.3);
      color: #ff6b6b;
    }

    .sync-indicator.sync-master {
      background: rgba(102, 126, 234, 0.2);
      border-color: rgba(102, 126, 234, 0.3);
      color: #667eea;
    }

    .sync-dot {
      width: 8px;
      height: 8px;
      background: currentColor;
      border-radius: 50%;
    }

    #videoContainer {
      width: 100%;
      border-radius: 15px;
      overflow: hidden;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      min-height: 400px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    #videoContainer iframe {
      width: 100%;
      height: 100%;
      border: none;
      border-radius: 15px;
    }

    .anime-overlay {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 8px 12px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 500;
      z-index: 10;
      backdrop-filter: blur(10px);
    }

    .anime-sync-controls {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 12px;
      z-index: 10;
      backdrop-filter: blur(10px);
      display: none;
      gap: 10px;
    }

    .anime-sync-controls.active {
      display: flex;
    }

    .anime-sync-btn {
      background: rgba(255, 255, 255, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.3);
      color: white;
      padding: 4px 8px;
      border-radius: 8px;
      font-size: 10px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .anime-sync-btn:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    .master-indicator {
      background: rgba(102, 126, 234, 0.2);
      border: 1px solid rgba(102, 126, 234, 0.3);
      color: #667eea;
      padding: 4px 8px;
      border-radius: 8px;
      font-size: 11px;
      margin-bottom: 10px;
      text-align: center;
    }

    .anime-sync-warning {
      background: rgba(255, 165, 0, 0.2);
      border: 1px solid rgba(255, 165, 0, 0.3);
      border-radius: 12px;
      padding: 12px;
      margin-bottom: 15px;
      color: #ffa500;
      font-size: 13px;
      text-align: center;
      display: none;
    }

    .sync-helper {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 15px;
      padding: 15px;
      max-width: 300px;
      z-index: 1000;
      backdrop-filter: blur(10px);
      display: none;
    }

    .sync-helper.active {
      display: block;
    }

    .sync-helper h4 {
      color: #667eea;
      margin-bottom: 10px;
      font-size: 14px;
    }

    .sync-helper-buttons {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }

    .sync-helper-btn {
      flex: 1;
      padding: 8px 12px;
      font-size: 12px;
      border-radius: 8px;
      border: none;
      cursor: pointer;
      font-weight: 500;
    }

    .sync-yes {
      background: #10ac84;
      color: white;
    }

    .sync-no {
      background: #ff6b6b;
      color: white;
    }

    .anime-search-container {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 12px;
      padding: 15px;
      margin-bottom: 15px;
      display: none;
    }

    .anime-search-container.active {
      display: block;
    }

    .anime-search-tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
    }

    .anime-tab {
      padding: 8px 16px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.2s ease;
    }

    .anime-tab.active {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-color: transparent;
    }

    .anime-results {
      max-height: 300px;
      overflow-y: auto;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 10px;
    }

    .anime-item {
      display: flex;
      gap: 10px;
      padding: 10px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .anime-item:hover {
      background: rgba(255, 255, 255, 0.1);
      transform: translateY(-2px);
    }

    .anime-thumbnail {
      width: 60px;
      height: 80px;
      object-fit: cover;
      border-radius: 6px;
      background: rgba(255, 255, 255, 0.1);
    }

    .anime-info {
      flex: 1;
    }

    .anime-title {
      font-weight: 500;
      font-size: 13px;
      margin-bottom: 4px;
      line-height: 1.3;
    }

    .anime-details {
      font-size: 11px;
      color: #888;
      margin-bottom: 6px;
    }

    .anime-episodes {
      font-size: 10px;
      color: #667eea;
      background: rgba(102, 126, 234, 0.2);
      padding: 2px 6px;
      border-radius: 10px;
      display: inline-block;
    }

    .settings-panel {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 15px;
      margin-bottom: 15px;
      display: none;
    }

    .settings-panel.active {
      display: block;
    }

    .setting-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .setting-item:last-child {
      border-bottom: none;
    }

    .setting-label {
      font-size: 13px;
      color: #fff;
    }

    .setting-description {
      font-size: 11px;
      color: #888;
      margin-top: 2px;
    }

    .toggle-switch {
      position: relative;
      width: 44px;
      height: 24px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      cursor: pointer;
      transition: background 0.3s ease;
    }

    .toggle-switch.active {
      background: #667eea;
    }

    .toggle-slider {
      position: absolute;
      top: 2px;
      left: 2px;
      width: 20px;
      height: 20px;
      background: white;
      border-radius: 50%;
      transition: transform 0.3s ease;
    }

    .toggle-switch.active .toggle-slider {
      transform: translateX(20px);
    }

    .history-panel {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 15px;
      margin-bottom: 15px;
      display: none;
    }

    .history-panel.active {
      display: block;
    }

    .history-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .history-item:last-child {
      border-bottom: none;
    }

    .history-title {
      font-size: 13px;
      color: #fff;
    }

    .history-progress {
      font-size: 11px;
      color: #888;
    }

    .progress-bar {
      width: 60px;
      height: 4px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 2px;
      overflow: hidden;
      margin-top: 2px;
    }

    .progress-fill {
      height: 100%;
      background: #667eea;
      transition: width 0.3s ease;
    }

    .controls {
      display: flex;
      gap: 15px;
      margin-top: 20px;
      flex-wrap: wrap;
    }

    .input-group {
      flex: 1;
      min-width: 300px;
    }

    input[type="text"], input[type="password"] {
      width: 100%;
      padding: 12px 16px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      color: white;
      font-size: 14px;
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
    }

    input[type="text"]:focus, input[type="password"]:focus {
      outline: none;
      border-color: #667eea;
      background: rgba(255, 255, 255, 0.15);
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
    }

    input[type="text"]::placeholder, input[type="password"]::placeholder {
      color: #aaa;
    }

    button, .btn-standard {
      padding: 12px 20px;
      background: #667eea;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.2s ease;
      min-width: 100px;
      text-align: center;
    }

    button:hover {
      background: #5a6fd8;
      transform: translateY(-1px);
    }

    button:active {
      transform: translateY(0);
    }

    button.secondary {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    button.secondary:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    button.danger {
      background: #ff6b6b;
    }

    button.danger:hover {
      background: #ff5252;
    }

    button.ready {
      background: #10ac84;
    }

    button.ready:hover {
      background: #00a085;
    }

    .section-title {
      font-size: 1.2rem;
      font-weight: 600;
      margin-bottom: 20px;
      color: #fff;
    }

    .user-list {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 15px;
    }

    .user {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 20px;
      font-size: 13px;
      font-weight: 500;
      transition: all 0.3s ease;
    }

    .user.ready {
      background: #10ac84;
      border-color: transparent;
      color: white;
    }

    .user.sync-master {
      background: #667eea;
      border-color: transparent;
      color: white;
    }

    .user-status {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #666;
      transition: all 0.3s ease;
    }

    .user.ready .user-status {
      background: #fff;
    }

    .user.sync-master .user-status {
      background: #fff;
    }

    .admin-icon {
      font-size: 10px;
      margin-left: 5px;
      background: #ffd700;
      color: #000;
      padding: 2px 4px;
      border-radius: 4px;
      font-weight: bold;
    }

    .sync-master-icon {
      font-size: 10px;
      margin-left: 5px;
      background: #667eea;
      color: #fff;
      padding: 2px 4px;
      border-radius: 4px;
      font-weight: bold;
    }

    .ready-status {
      text-align: center;
      padding: 15px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 12px;
      margin-bottom: 15px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .skip-vote-status {
      text-align: center;
      padding: 15px;
      background: rgba(255, 107, 107, 0.1);
      border: 1px solid rgba(255, 107, 107, 0.2);
      border-radius: 12px;
      margin-bottom: 15px;
      display: none;
    }

    .kick-vote-status {
      text-align: center;
      padding: 15px;
      background: rgba(255, 165, 0, 0.1);
      border: 1px solid rgba(255, 165, 0, 0.2);
      border-radius: 12px;
      margin-bottom: 15px;
      display: none;
    }

    .user-actions {
      display: flex;
      gap: 5px;
      margin-top: 5px;
    }

    .kick-btn {
      padding: 6px 10px;
      font-size: 11px;
      background: rgba(255, 107, 107, 0.2);
      border: 1px solid rgba(255, 107, 107, 0.3);
      color: #ff6b6b;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      font-weight: 500;
    }

    .kick-btn:hover {
      background: rgba(255, 107, 107, 0.3);
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(255, 107, 107, 0.2);
    }

    .kick-btn.voted {
      background: rgba(255, 107, 107, 0.4);
      color: #fff;
      border-color: #ff6b6b;
    }

    .queue-list {
      max-height: 400px;
      overflow-y: auto;
    }

    .queue-item {
      display: flex;
      align-items: center;
      gap: 15px;
      padding: 15px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      margin-bottom: 10px;
      transition: all 0.3s ease;
      position: relative;
    }

    .queue-item:hover {
      background: rgba(255, 255, 255, 0.1);
      transform: translateX(5px);
    }

    .queue-item .remove-btn {
      padding: 6px 10px;
      font-size: 11px;
      background: rgba(255, 107, 107, 0.2);
      border: 1px solid rgba(255, 107, 107, 0.3);
      color: #ff6b6b;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      font-weight: 500;
      min-width: 60px;
    }

    .queue-item .remove-btn:hover {
      background: rgba(255, 107, 107, 0.3);
      transform: translateY(-1px);
    }

    .vote-progress {
      margin-top: 10px;
      padding: 10px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .vote-bar {
      width: 100%;
      height: 6px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
      overflow: hidden;
      margin-top: 5px;
    }

    .vote-progress-fill {
      height: 100%;
      background: #ff6b6b;
      transition: width 0.3s ease;
    }

    .queue-number {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 30px;
      height: 30px;
      background: #667eea;
      border-radius: 50%;
      font-weight: 600;
      font-size: 12px;
      color: white;
    }

    .queue-title {
      flex: 1;
      font-size: 14px;
      line-height: 1.4;
      color: #fff;
      word-break: break-all;
    }

    .notification {
      position: fixed;
      top: 60px;
      right: 20px;
      background: #667eea;
      color: white;
      padding: 15px 20px;
      border-radius: 8px;
      display: none;
      z-index: 1001;
      font-weight: 500;
      max-width: 350px;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .notification.success {
      background: #10ac84;
    }

    .notification.warning {
      background: #ff9500;
    }

    .notification.error {
      background: #ff6b6b;
    }

    .empty-state {
      text-align: center;
      padding: 40px 20px;
      color: #666;
    }

    .empty-state svg {
      width: 60px;
      height: 60px;
      margin-bottom: 15px;
      opacity: 0.5;
    }

    .connection-status {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 12px;
      font-weight: 500;
      z-index: 1002;
      backdrop-filter: blur(10px);
    }

    .connection-status.connected {
      background: rgba(16, 172, 132, 0.2);
      border: 1px solid rgba(16, 172, 132, 0.5);
      color: #10ac84;
    }

    .connection-status.disconnected {
      background: rgba(255, 107, 107, 0.2);
      border: 1px solid rgba(255, 107, 107, 0.5);
      color: #ff6b6b;
    }

    /* Scrollbar styles */
    ::-webkit-scrollbar {
      width: 8px;
    }

    ::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.2);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    .search-container {
      margin-bottom: 15px;
    }

    .search-results {
      max-height: 300px;
      overflow-y: auto;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 12px;
      margin-top: 10px;
      display: none;
    }

    .search-item {
      display: flex;
      gap: 15px;
      padding: 10px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      cursor: pointer;
      transition: background 0.2s;
    }

    .search-item:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .search-thumbnail {
      width: 120px;
      height: 68px;
      object-fit: cover;
      border-radius: 8px;
    }

    .search-info {
      flex: 1;
    }

    .search-title {
      font-weight: 500;
      margin-bottom: 5px;
      line-height: 1.3;
    }

    .search-channel {
      color: #888;
      font-size: 12px;
    }

    /* Enhanced mobile responsiveness */
    @media (max-width: 1024px) {
      .main-content {
        gap: 20px;
      }
    }

    @media (max-width: 768px) {
      .container {
        padding: 10px;
      }
      
      .header h1 {
        font-size: 2rem;
      }

      .platform-info {
        gap: 10px;
        margin-bottom: 10px;
      }

      .platform-badge {
        padding: 4px 8px;
        font-size: 11px;
      }

      .platform-icon {
        width: 12px;
        height: 12px;
      }

      .stats-display {
        gap: 15px;
        margin-bottom: 15px;
      }

      .stat-item {
        padding: 10px 15px;
        min-width: 100px;
      }

      .stat-number {
        font-size: 1.5rem;
      }

      .stat-label {
        font-size: 0.8rem;
      }
      
      .controls {
        flex-direction: column;
        gap: 10px;
      }
      
      .input-group {
        min-width: unset;
      }
      
      .queue-list {
        max-height: 250px;
      }
      
      .search-item {
        flex-direction: column;
        gap: 10px;
      }
      
      .search-thumbnail {
        width: 100%;
        height: auto;
      }
      
      .user-actions {
        flex-direction: column;
        gap: 3px;
      }
      
      .kick-btn {
        font-size: 9px;
        padding: 3px 6px;
      }

      .anime-sync-warning {
        font-size: 12px;
        padding: 10px;
      }

      .sync-helper {
        left: 10px;
        right: 10px;
        bottom: 10px;
        max-width: none;
      }

      .anime-search-container {
        padding: 10px;
      }

      .anime-results {
        grid-template-columns: 1fr;
      }

      .settings-panel, .history-panel {
        padding: 10px;
      }

      .anime-sync-controls {
        bottom: 5px;
        padding: 6px 12px;
        gap: 6px;
      }

      .anime-sync-btn {
        padding: 3px 6px;
        font-size: 9px;
      }

      .master-indicator {
        font-size: 10px;
        padding: 3px 6px;
      }
    }

    @media (max-width: 480px) {
      .header h1 {
        font-size: 1.5rem;
      }

      .platform-info {
        gap: 8px;
        margin-bottom: 8px;
      }

      .platform-badge {
        padding: 3px 6px;
        font-size: 10px;
      }

      .platform-icon {
        width: 10px;
        height: 10px;
      }

      .stats-display {
        gap: 10px;
        margin-bottom: 10px;
      }

      .stat-item {
        padding: 8px 12px;
        min-width: 80px;
      }

      .stat-number {
        font-size: 1.3rem;
      }

      .stat-label {
        font-size: 0.75rem;
      }
      
      .login-section {
        padding: 20px;
        margin: 10px;
      }
      
      .video-section, .queue-section, .users-section {
        padding: 15px;
      }
      
      .notification {
        font-size: 12px;
        padding: 10px 15px;
        max-width: 280px;
      }

      .anime-sync-warning {
        font-size: 11px;
        padding: 8px;
        margin-bottom: 10px;
      }

      .sync-helper {
        font-size: 12px;
        padding: 10px;
      }

      .sync-helper-btn {
        padding: 6px 8px;
        font-size: 11px;
      }

      .anime-search-tabs {
        gap: 5px;
      }

      .anime-tab {
        padding: 6px 12px;
        font-size: 11px;
      }

      .setting-item {
        padding: 8px 0;
      }

      .setting-label {
        font-size: 12px;
      }

      .setting-description {
        font-size: 10px;
      }

      .anime-sync-controls {
        bottom: 3px;
        padding: 4px 8px;
        gap: 4px;
      }

      .anime-sync-btn {
        padding: 2px 4px;
        font-size: 8px;
      }

      .master-indicator {
        font-size: 9px;
        padding: 2px 4px;
        margin-bottom: 5px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>WatchTogether</h1>
      <p>Watch YouTube videos together in perfect sync</p>
      <div class="platform-info">
        <div class="platform-badge">
          <div class="platform-icon youtube"></div>
          <span>YouTube</span>
        </div>
        <div class="platform-badge">
          <div class="platform-icon anime"></div>
          <span>AnimeKai</span>
        </div>
        <div class="platform-badge">
          <div class="platform-icon vimeo"></div>
          <span>Vimeo</span>
        </div>
        <div class="platform-badge">
          <div class="platform-icon twitch"></div>
          <span>Twitch</span>
        </div>
      </div>
      <div class="stats-display">
        <div class="stat-item">
          <div class="stat-number" id="totalUsers">-</div>
          <div class="stat-label">Users Online</div>
        </div>
        <div class="stat-item">
          <div class="stat-number" id="activeRooms">-</div>
          <div class="stat-label">Active Rooms</div>
        </div>
      </div>
    </div>

    <div id="loginSection" class="login-section">
      <h2 id="loginTitle" style="margin-bottom: 20px; font-weight: 600;">Join a Room</h2>
      <div style="display: flex; flex-direction: column; gap: 15px;">
        <input type="text" id="nameInput" placeholder="Enter your name" style="text-align: center;">
        <input type="text" id="roomInput" placeholder="Enter room ID" style="text-align: center;">
        <div id="passwordSection" style="display: none;">
          <input type="password" id="passwordInput" placeholder="Enter room password" style="text-align: center;">
        </div>
        <div id="createPasswordSection" style="display: none;">
          <input type="password" id="createPasswordInput" placeholder="Set room password (optional)" style="text-align: center; margin-bottom: 5px;">
          <small style="color: #888; font-size: 12px; display: block; text-align: center;">Leave empty for no password</small>
        </div>
        <button id="joinBtn" style="margin-top: 10px;">Check Room</button>
        <button id="createRoomBtn" style="display: none;">Create Room</button>
      </div>
    </div>

    <div id="appSection" class="app-section">
      <div class="main-content">
        <!-- Video Player Section -->
        <div class="video-section">
          <div class="current-video">
            <h2>Now Playing</h2>
            <div id="videoTitle" class="video-title">No video selected</div>
            <div id="syncIndicator" class="sync-indicator">
              <div class="sync-dot"></div>
              <span id="syncStatus">In Sync</span>
            </div>
            <div id="animeSyncWarning" class="anime-sync-warning">
              ðŸŽŒ Anime Mode: Manual sync required. Use the buttons below for sync hints or coordinate with other viewers.
            </div>
          </div>
          
          <div id="videoContainer">
            <div class="empty-state">
              <svg viewBox="0 0 24 24" fill="currentColor">
                <path d="M8,5.14V19.14L19,12.14L8,5.14Z" />
              </svg>
              <p>Add a video to get started</p>
            </div>
          </div>

          <div class="controls">
            <div style="display: flex; gap: 15px; flex-wrap: wrap; margin-bottom: 15px;">
              <div class="input-group" style="flex: 1; min-width: 300px;">
                <input type="text" id="videoInput" placeholder="Paste YouTube, AnimeKai, Vimeo, or Twitch URL">
              </div>
              <button id="addVideoBtn" class="btn-standard">Add Video</button>
            </div>
            
            <div class="search-container" style="width: 100%; margin-bottom: 15px;">
              <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                <input type="text" id="searchInput" placeholder="Search YouTube videos & live streams..." style="flex: 1;">
                <button id="searchBtn" class="btn-standard secondary">Search</button>
                <button id="animeSearchBtn" class="btn-standard secondary">Anime</button>
              </div>
              <div id="searchResults" class="search-results"></div>
              
              <!-- Anime Search Container -->
              <div id="animeSearchContainer" class="anime-search-container">
                <div class="anime-search-tabs">
                  <div class="anime-tab active" data-tab="popular">Popular</div>
                  <div class="anime-tab" data-tab="search">Search</div>
                </div>
                <div id="animeSearchInput" style="display: none; margin-bottom: 10px;">
                  <input type="text" id="animeQuery" placeholder="Search anime..." style="width: 100%;">
                </div>
                <div id="animeResults" class="anime-results"></div>
              </div>
            </div>
            
            <div class="button-row" style="display: flex; gap: 10px; flex-wrap: wrap;">
              <button id="readyBtn" class="btn-standard ready">Ready</button>
              <button id="skipBtn" class="btn-standard secondary">Vote Skip</button>
              <button id="inviteBtn" class="btn-standard secondary">Invite</button>
              <button id="settingsBtn" class="btn-standard secondary">Settings</button>
              <button id="historyBtn" class="btn-standard secondary">History</button>
            </div>

            <!-- Settings Panel -->
            <div id="settingsPanel" class="settings-panel">
              <h4 style="margin-bottom: 15px; color: #667eea;">Room Settings</h4>
              <div class="setting-item">
                <div>
                  <div class="setting-label">Auto Episode Progression</div>
                  <div class="setting-description">Automatically play next episode when current ends</div>
                </div>
                <div class="toggle-switch" id="autoProgressionToggle">
                  <div class="toggle-slider"></div>
                </div>
              </div>
              <div class="setting-item">
                <div>
                  <div class="setting-label">Anime Sync Assistance</div>
                  <div class="setting-description">Enhanced sync coordination for anime episodes</div>
                </div>
                <div class="toggle-switch active" id="syncAssistanceToggle">
                  <div class="toggle-slider"></div>
                </div>
              </div>
              <div class="setting-item">
                <div>
                  <div class="setting-label">Watch History</div>
                  <div class="setting-description">Track watched episodes and progress</div>
                </div>
                <div class="toggle-switch active" id="watchHistoryToggle">
                  <div class="toggle-slider"></div>
                </div>
              </div>
            </div>

            <!-- Watch History Panel -->
            <div id="historyPanel" class="history-panel">
              <h4 style="margin-bottom: 15px; color: #667eea;">Watch History</h4>
              <div id="historyList"></div>
            </div>
          </div>
        </div>

        <!-- Queue Section -->
        <div class="queue-section">
          <h3 class="section-title">Up Next</h3>
          <div id="queueList" class="queue-list">
            <div class="empty-state">
              <svg viewBox="0 0 24 24" fill="currentColor">
                <path d="M15,6H3V8H15V6M15,10H3V12H15V10M3,16H11V14H3V16M17,6V14.5L22,9.5L17,6Z" />
              </svg>
              <p>Queue is empty</p>
            </div>
          </div>
        </div>

        <!-- Users Section -->
        <div class="users-section">
          <div class="users-toggle" onclick="toggleUsers()">
            <h3 class="section-title" style="margin-bottom: 0;">Users in Room</h3>
            <span class="toggle-icon" id="usersToggleIcon">â–¼</span>
          </div>
          
          <div id="usersContent" class="users-content expanded">
            <div id="userList" class="user-list"></div>
            <div id="readyStatus" class="ready-status"></div>
            <div id="skipVoteStatus" class="skip-vote-status"></div>
            <div id="kickVoteStatus" class="kick-vote-status"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div id="notification" class="notification"></div>
  <div id="connectionStatus" class="connection-status disconnected">Disconnected</div>
  
  <!-- Enhanced Anime Sync Helper -->
  <div id="syncHelper" class="sync-helper">
    <h4>Anime Sync Check</h4>
    <p id="syncHelperMessage">Are you still watching and in sync?</p>
    <div class="sync-helper-buttons">
      <button class="sync-helper-btn sync-yes" onclick="respondToSyncCheck(true)">Yes, in sync</button>
      <button class="sync-helper-btn sync-no" onclick="respondToSyncCheck(false)">Need to resync</button>
    </div>
  </div>

  <script>
    let socket;
    let player;
    let currentRoom = "";
    let isReady = false;
    let hasVotedSkip = false;
    let usersExpanded = true;
    let userKickVotes = new Map();
    let currentUsers = new Map();
    let currentSkipVotes = { votes: 0, total: 0 };
    let currentKickVotes = {};
    let isLeavingRoom = false;
    let currentUserData = null;
    let currentPlatform = null; // Track current video platform
    let isAnimeMode = false; // Track if currently playing anime

    // Enhanced anime features
    let animeSearchActive = false;
    let currentAnimeTab = 'popular';
    let roomSettings = {
      autoProgression: true,
      syncAssistance: true,
      watchHistory: true
    };
    let watchHistory = JSON.parse(localStorage.getItem('watchTogether_history') || '{}');
    let syncCheckActive = false;

    // Anime sync master-slave system
    let animeSyncState = {
      isMaster: false,
      currentTime: 0,
      isPaused: false,
      lastUpdate: 0,
      episodeStartTime: 0,
      syncOffset: 0, // Difference between estimated and master time
      commandCooldown: 0,
      masterState: null
    };

    // High-Precision Sync System
    let precisionSync = {
      // Server sync data
      serverTime: 0,
      serverCurrentTime: 0,
      serverIsPaused: false,
      serverPlaybackRate: 1.0,
      lastServerUpdate: 0,
      
      // Network compensation
      networkLatency: 0,
      latencyHistory: [],
      clockOffset: 0,
      
      // Predictive sync
      predictedTime: 0,
      driftCorrection: 0,
      syncAccuracy: 0,
      
      // Quality monitoring
      syncQuality: 'excellent', // excellent, good, fair, poor
      lastSyncCheck: 0,
      syncErrors: 0,
      
      // Configuration
      syncTolerance: 0.5, // Much tighter tolerance for precision
      maxLatency: 200,    // Max acceptable latency in ms
      syncInterval: null,
      latencyInterval: null
    };

    // Legacy sync state for compatibility
    let syncState = {
      isSyncMaster: false,
      isInSync: true,
      preventSync: false
    };

    const SERVER_URL = window.location.origin;

    // High-Precision Sync Functions
    function initializePrecisionSync() {
      // Start latency measurement
      startLatencyMeasurement();
      
      // Start local sync monitoring
      startSyncMonitoring();
      
      console.log('Precision sync system initialized');
    }

    function startLatencyMeasurement() {
      if (precisionSync.latencyInterval) {
        clearInterval(precisionSync.latencyInterval);
      }
      
      // Measure latency every 5 seconds
      precisionSync.latencyInterval = setInterval(() => {
        if (currentRoom && socket && socket.connected) {
          const timestamp = Date.now();
          socket.emit("latencyPing", { roomId: currentRoom, timestamp });
        }
      }, 5000);
    }

    function calculatePredictedTime() {
      if (!precisionSync.lastServerUpdate) return 0;
      
      const now = Date.now();
      const timeSinceUpdate = (now - precisionSync.lastServerUpdate) / 1000;
      const networkCompensation = precisionSync.networkLatency / 2000; // Half RTT
      
      if (precisionSync.serverIsPaused) {
        precisionSync.predictedTime = precisionSync.serverCurrentTime;
      } else {
        // Predict current time with drift correction
        precisionSync.predictedTime = precisionSync.serverCurrentTime + 
          (timeSinceUpdate * precisionSync.serverPlaybackRate) + 
          precisionSync.driftCorrection - networkCompensation;
      }
      
      return precisionSync.predictedTime;
    }

    function startSyncMonitoring() {
      if (precisionSync.syncInterval) {
        clearInterval(precisionSync.syncInterval);
      }
      
      // Check sync accuracy every 100ms for high precision
      precisionSync.syncInterval = setInterval(() => {
        if (player && player.getCurrentTime && !isAnimeMode) {
          checkSyncAccuracy();
        }
      }, 100);
    }

    function checkSyncAccuracy() {
      if (!player || isAnimeMode) return;
      
      const playerTime = player.getCurrentTime();
      const predictedTime = calculatePredictedTime();
      const timeDifference = Math.abs(playerTime - predictedTime);
      
      precisionSync.syncAccuracy = timeDifference;
      
      // Update sync quality based on accuracy
      if (timeDifference < 0.2) {
        precisionSync.syncQuality = 'excellent';
      } else if (timeDifference < 0.5) {
        precisionSync.syncQuality = 'good';
      } else if (timeDifference < 1.0) {
        precisionSync.syncQuality = 'fair';
      } else {
        precisionSync.syncQuality = 'poor';
        precisionSync.syncErrors++;
      }
      
      // Apply correction if needed
      if (timeDifference > precisionSync.syncTolerance) {
        applySyncCorrection(predictedTime, precisionSync.serverIsPaused);
      }
      
      updateSyncIndicator();
    }

    // Legacy sync system (keep for compatibility)
    function initializeSyncSystem() {
      // Initialize precision sync instead
      initializePrecisionSync();
    }

    function updateSyncMasterStatus(isMaster) {
      console.log(`Sync master status changed: ${isMaster}`);
      syncState.isSyncMaster = isMaster;
      
      // Update anime sync master status
      if (isAnimeMode) {
        animeSyncState.isMaster = isMaster;
        if (isMaster) {
          startAnimeMasterTracking();
          // Update UI to show master status
          const masterIndicator = document.querySelector('.master-indicator');
          if (masterIndicator) {
            masterIndicator.textContent = 'You are the Sync Master';
            masterIndicator.style.display = 'block';
          }
          // Hide slave controls
          const syncControls = document.getElementById('animeSyncControls');
          if (syncControls) {
            syncControls.classList.remove('active');
          }
        } else {
          // Show slave controls
          const syncControls = document.getElementById('animeSyncControls');
          if (syncControls) {
            syncControls.classList.add('active');
          }
        }
      }
      
      updateSyncIndicator();
    }

    function checkSyncStatus() {
      // Skip sync checks for anime since we can't control iframe players
      if (isAnimeMode) {
        syncState.isInSync = true;
        updateSyncIndicator();
        return;
      }
      
      if (!player || !player.getCurrentTime || syncState.preventSync) return;

      const currentTime = player.getCurrentTime();
      const playerState = player.getPlayerState();
      
      if (playerState === YT.PlayerState.PLAYING) {
        const timeDifference = Math.abs(currentTime - syncState.lastKnownTime);
        const wasInSync = syncState.isInSync;
        syncState.isInSync = timeDifference <= syncState.adaptiveTolerance.current;
        
        // Only show sync status changes to avoid spam
        if (wasInSync !== syncState.isInSync) {
          updateSyncIndicator();
          
          // If we're out of sync and not the master, request sync
          if (!syncState.isInSync && !syncState.isSyncMaster) {
            requestSync();
          }
        }
      }
    }

    function broadcastSyncHeartbeat() {
      if (!syncState.isSyncMaster || !currentRoom || syncState.preventSync) return;
      
      // For anime mode, we can't get precise timing, so we use manual sync
      if (isAnimeMode) {
        // Don't broadcast automatic heartbeats for anime
        return;
      }
      
      if (!player) return;

      const now = Date.now();
      if (now - syncState.lastSyncBroadcast < syncState.syncCooldown) return;

      const currentTime = player.getCurrentTime();
      const playerState = player.getPlayerState();
      const isPaused = playerState !== YT.PlayerState.PLAYING;

      // Only broadcast if there's meaningful change or periodically
      const timeDelta = Math.abs(currentTime - syncState.lastKnownTime);
      const shouldBroadcast = timeDelta > 0.5 || (now - syncState.lastSyncBroadcast) > 10000; // 10 second maximum interval

      if (shouldBroadcast && socket && socket.connected) {
        console.log('Sync master broadcasting heartbeat:', { currentTime, isPaused });
        socket.emit("syncHeartbeat", {
          roomId: currentRoom,
          currentTime: currentTime,
          isPaused: isPaused,
          timestamp: now
        });
        
        syncState.lastKnownTime = currentTime;
        syncState.lastSyncBroadcast = now;
      }
    }

    function requestSync() {
      if (syncState.isSyncMaster || !socket || !currentRoom) return;

      console.log('Requesting sync from master');
      socket.emit("requestSync", { roomId: currentRoom });
    }

    // High-Precision Sync Handlers
    function handlePrecisionSync(data) {
      const { serverTime, currentTime, isPaused, playbackRate, timestamp } = data;
      const now = Date.now();
      
      // Update precision sync state
      precisionSync.serverTime = serverTime;
      precisionSync.serverCurrentTime = currentTime;
      precisionSync.serverIsPaused = isPaused;
      precisionSync.serverPlaybackRate = playbackRate || 1.0;
      precisionSync.lastServerUpdate = now;
      
      // Calculate clock offset for better synchronization
      const networkDelay = now - timestamp;
      if (networkDelay > 0 && networkDelay < 5000) { // Sanity check
        precisionSync.clockOffset = (serverTime + networkDelay/2) - now;
      }
      
      console.log(`Precision sync: ${currentTime.toFixed(2)}s, paused: ${isPaused}, latency: ${networkDelay}ms`);
    }

    function handleLatencyMeasurement(data) {
      const { originalTimestamp, serverTimestamp, latency } = data;
      const now = Date.now();
      const roundTripTime = now - originalTimestamp;
      
      // Update latency tracking
      precisionSync.networkLatency = latency;
      precisionSync.latencyHistory.push(latency);
      
      // Keep only last 10 measurements
      if (precisionSync.latencyHistory.length > 10) {
        precisionSync.latencyHistory.shift();
      }
      
      // Calculate average latency for compensation
      const avgLatency = precisionSync.latencyHistory.reduce((a, b) => a + b, 0) / precisionSync.latencyHistory.length;
      precisionSync.networkLatency = avgLatency;
      
      console.log(`Network latency: ${latency}ms (avg: ${avgLatency.toFixed(1)}ms)`);
    }

    // Legacy sync handler (keep for compatibility)
    function handleSyncHeartbeat(data) {
      // Redirect to precision sync if available
      if (data.serverTime) {
        handlePrecisionSync(data);
        return;
      }
      
      // Fallback to old method for compatibility
      if (syncState.isSyncMaster) return;

      const { currentTime, isPaused, timestamp } = data;
      const now = Date.now();
      const networkDelay = (now - timestamp) / 1000;
      const adjustedTime = currentTime + networkDelay;

      if (player && player.getCurrentTime) {
        const playerTime = player.getCurrentTime();
        const playerPaused = player.getPlayerState() !== YT.PlayerState.PLAYING;
        const timeDifference = Math.abs(playerTime - adjustedTime);

        if (timeDifference > 2.0 || playerPaused !== isPaused) {
          applySyncCorrection(adjustedTime, isPaused);
        }
      }
    }

    function applySyncCorrection(targetTime, shouldBePaused) {
      // For anime mode, we can't directly control the player
      if (isAnimeMode) {
        console.log(`Anime sync hint: ${shouldBePaused ? 'Pause' : 'Play'} at ${Math.floor(targetTime)}s`);
        // Show a less intrusive notification for anime sync
        showNotification(`Sync hint: ${shouldBePaused ? 'Pause' : 'Play'} at ${Math.floor(targetTime)}s`, "info", 2000);
        syncState.isInSync = true;
        updateSyncIndicator('syncing');
        setTimeout(() => {
          updateSyncIndicator();
        }, 2000);
        return;
      }
      
      if (!player || syncState.preventSync) return;

      console.log(`Applying sync correction: ${targetTime}s, paused: ${shouldBePaused}`);
      
      syncState.preventSync = true;
      
      try {
        player.seekTo(targetTime, true);
        
        if (shouldBePaused) {
          player.pauseVideo();
        } else {
          player.playVideo();
        }

        // Update sync status
        syncState.isInSync = true;
        updateSyncIndicator('syncing');
        
        // Clear syncing status after a moment
        setTimeout(() => {
          updateSyncIndicator();
        }, 1000);

      } catch (error) {
        console.error('Error applying sync correction:', error);
      }
      
      // Re-enable sync after a brief cooldown
      setTimeout(() => {
        syncState.preventSync = false;
      }, 2000);
    }

    function updateSyncIndicator(status = null) {
      const indicator = document.getElementById('syncIndicator');
      const statusText = document.getElementById('syncStatus');
      
      if (!indicator || !statusText) return;

      let className = 'sync-indicator';
      let text = 'Sync Status';

      if (status === 'syncing') {
        className += ' syncing';
        text = 'Syncing...';
      } else if (precisionSync.syncQuality && !isAnimeMode) {
        // Use precision sync quality for YouTube/Vimeo/Twitch
        switch(precisionSync.syncQuality) {
          case 'excellent':
            className += ' in-sync';
            text = `Excellent (Â±${(precisionSync.syncAccuracy * 1000).toFixed(0)}ms)`;
            break;
          case 'good':
            className += ' in-sync';
            text = `Good (Â±${(precisionSync.syncAccuracy * 1000).toFixed(0)}ms)`;
            break;
          case 'fair':
            className += ' syncing';
            text = `Fair (Â±${(precisionSync.syncAccuracy * 1000).toFixed(0)}ms)`;
            break;
          case 'poor':
            className += ' out-of-sync';
            text = `Poor (Â±${(precisionSync.syncAccuracy * 1000).toFixed(0)}ms)`;
            break;
        }
      } else if (!syncState.isInSync) {
        className += ' out-of-sync';
        text = 'Out of Sync';
      } else if (syncState.isSyncMaster) {
        className += ' sync-master';
        text = 'Sync Master';
      } else {
        className += ' in-sync';
        text = 'In Sync';
      }

      indicator.className = className;
      statusText.textContent = text;
    }

    // Utility Functions
    function extractVideoID(url) {
      const match = url.match(/[?&]v=([^&]+)/);
      if (match && match[1]) return match[1];
      const shortMatch = url.match(/youtu\.be\/([^?&]+)/);
      if (shortMatch && shortMatch[1]) return shortMatch[1];
      return url.trim();
    }

    function showNotification(message, type = 'info', duration = 4000) {
      const notification = document.getElementById("notification");
      notification.textContent = message;
      notification.className = `notification ${type}`;
      notification.style.display = "block";
      setTimeout(() => {
        notification.style.display = "none";
      }, duration);
    }

    function updateConnectionStatus(connected) {
      const status = document.getElementById("connectionStatus");
      if (connected) {
        status.textContent = "Connected";
        status.className = "connection-status connected";
      } else {
        status.textContent = "Disconnected";
        status.className = "connection-status disconnected";
      }
    }

    function updateVideoTitle(videoId, videoInfo) {
      if (videoId) {
        if (videoInfo && videoInfo.title) {
          let titleHtml = `<div style="font-weight: 600; margin-bottom: 5px;">${videoInfo.title}</div>`;
          
          if (videoInfo.platform === 'anime') {
            titleHtml += `<div style="font-size: 0.8em; color: #4ecdc4;">AnimeKai â€¢ Episode ${videoInfo.episode}</div>`;
          } else {
            titleHtml += `<div style="font-size: 0.8em; color: #aaa;">by ${videoInfo.channelTitle}</div>`;
          }
          
          document.getElementById("videoTitle").innerHTML = titleHtml;
        } else {
          // Fallback for when we don't have detailed video info
          if (currentPlatform === 'anime') {
            document.getElementById("videoTitle").textContent = `Anime Episode`;
          } else {
            document.getElementById("videoTitle").textContent = `https://youtube.com/watch?v=${videoId}`;
          }
        }
      } else {
        document.getElementById("videoTitle").textContent = "No video selected";
      }
    }

    function toggleUsers() {
      usersExpanded = !usersExpanded;
      const content = document.getElementById("usersContent");
      const icon = document.getElementById("usersToggleIcon");
      
      if (usersExpanded) {
        content.className = "users-content expanded";
        icon.textContent = "â–¼";
        icon.classList.remove("rotated");
      } else {
        content.className = "users-content collapsed";
        icon.textContent = "â–¶";
        icon.classList.add("rotated");
      }
    }

    // Event Handlers
    document.getElementById("joinBtn").onclick = () => {
      const name = document.getElementById("nameInput").value.trim();
      const room = document.getElementById("roomInput").value.trim();
      
      if (!name || !room) {
        showNotification("Please enter both name and room ID", "error");
        return;
      }

      if (!socket) {
        console.log("Connecting to:", SERVER_URL);
        socket = io(SERVER_URL);
        
        socket.on("connect", () => {
          console.log("Connected to server");
          isLeavingRoom = false;
          updateConnectionStatus(true);
          setTimeout(() => {
            checkRoom(room, name);
          }, 100);
        });

        socket.on("disconnect", () => {
          console.log("Disconnected from server");
          isLeavingRoom = true;
          updateConnectionStatus(false);
          showNotification("Disconnected from server", "error");
        });

        socket.on("connect_error", (error) => {
          console.error("Connection error:", error);
          updateConnectionStatus(false);
          showNotification("Failed to connect to server", "error");
        });

        setupSocketListeners();
      } else {
        checkRoom(room, name);
      }
    };

    document.getElementById("createRoomBtn").onclick = () => {
      const name = document.getElementById("nameInput").value.trim();
      const room = document.getElementById("roomInput").value.trim();
      const password = document.getElementById("createPasswordInput").value.trim();
      
      if (!name || !room) {
        showNotification("Please enter both name and room ID", "error");
        return;
      }

      currentRoom = room;
      socket.emit("createRoom", { roomId: room, userName: name, password: password || null });
    };

    function checkRoom(room, name) {
      socket.emit("checkRoom", room);
    }

    function kickUser(userId, userName) {
      if (!isCurrentUserAdmin()) {
        showNotification("Only admin can kick users", "error");
        return;
      }

      if (currentRoom && socket) {
        console.log("Admin kicking user:", userName);
        socket.emit("voteKick", { roomId: currentRoom, targetUserName: userName });
      }
    }

    // Enhanced anime search functions
    async function searchAnime(query = null) {
      try {
        let endpoint = `${SERVER_URL}/api/anime/popular`;
        if (query) {
          endpoint = `${SERVER_URL}/api/anime/search?q=${encodeURIComponent(query)}`;
        }

        const response = await fetch(endpoint);
        const data = await response.json();
        
        if (response.ok && data.anime) {
          displayAnimeResults(data.anime);
          if (query) {
            showNotification(`Found ${data.anime.length} anime`, "success");
          }
        } else {
          showNotification("Failed to load anime", "error");
        }
      } catch (error) {
        console.error("Anime search error:", error);
        showNotification("Anime search failed", "error");
      }
    }

    function displayAnimeResults(animeList) {
      const resultsContainer = document.getElementById("animeResults");
      
      if (animeList.length === 0) {
        resultsContainer.innerHTML = '<div style="text-align: center; color: #888; padding: 20px;">No anime found</div>';
        return;
      }

      resultsContainer.innerHTML = animeList.map(anime => `
        <div class="anime-item" onclick="selectAnime('${anime.slug}', '${anime.title.replace(/'/g, "\\'")}', ${anime.episodes})">
          <img src="${anime.thumbnail}" alt="${anime.title}" class="anime-thumbnail" 
               onerror="this.style.background='linear-gradient(45deg, #667eea, #764ba2)'">
          <div class="anime-info">
            <div class="anime-title">${anime.title}</div>
            <div class="anime-details">${anime.genre || 'Action, Adventure'} â€¢ ${anime.year}</div>
            <div class="anime-episodes">${anime.episodes} episodes</div>
          </div>
        </div>
      `).join('');
    }

    function selectAnime(slug, title, totalEpisodes) {
      // Show episode selection or add first episode
      const episodeUrl = `https://animekai.ac/watch/${slug}#ep=1`;
      
      if (currentRoom && socket) {
        console.log("Adding anime from search:", episodeUrl);
        socket.emit("addVideo", { roomId: currentRoom, videoUrl: episodeUrl });
        showNotification(`Added: ${title} - Episode 1`, "success");
        
        // Add to watch history
        addToWatchHistory(slug, title, 1, totalEpisodes);
      } else {
        document.getElementById("videoInput").value = episodeUrl;
        showNotification(`Selected: ${title}`, "info");
      }
      
      // Hide anime search
      document.getElementById("animeSearchContainer").classList.remove('active');
      animeSearchActive = false;
    }

    // Watch history functions
    function addToWatchHistory(animeSlug, animeTitle, episode, totalEpisodes) {
      if (!roomSettings.watchHistory) return;
      
      const key = animeSlug;
      const now = Date.now();
      
      if (!watchHistory[key]) {
        watchHistory[key] = {
          title: animeTitle,
          totalEpisodes: totalEpisodes,
          watchedEpisodes: new Set(),
          lastWatched: now,
          progress: {}
        };
      }
      
      watchHistory[key].watchedEpisodes.add(episode);
      watchHistory[key].lastWatched = now;
      watchHistory[key].progress[episode] = { startTime: now, completed: false };
      
      // Convert Set to Array for storage
      const historyForStorage = { ...watchHistory };
      Object.keys(historyForStorage).forEach(key => {
        historyForStorage[key].watchedEpisodes = Array.from(historyForStorage[key].watchedEpisodes);
      });
      
      localStorage.setItem('watchTogether_history', JSON.stringify(historyForStorage));
      console.log(`Added to watch history: ${animeTitle} Episode ${episode}`);
    }

    function loadWatchHistory() {
      try {
        const stored = localStorage.getItem('watchTogether_history');
        if (stored) {
          const parsed = JSON.parse(stored);
          // Convert Arrays back to Sets
          Object.keys(parsed).forEach(key => {
            parsed[key].watchedEpisodes = new Set(parsed[key].watchedEpisodes);
          });
          watchHistory = parsed;
        }
      } catch (error) {
        console.error('Failed to load watch history:', error);
        watchHistory = {};
      }
    }

    function displayWatchHistory() {
      const historyList = document.getElementById("historyList");
      const historyEntries = Object.entries(watchHistory)
        .sort((a, b) => b[1].lastWatched - a[1].lastWatched)
        .slice(0, 10); // Show last 10 entries
      
      if (historyEntries.length === 0) {
        historyList.innerHTML = '<div style="text-align: center; color: #888; padding: 20px;">No watch history yet</div>';
        return;
      }

      historyList.innerHTML = historyEntries.map(([slug, data]) => {
        const progressPercent = (data.watchedEpisodes.size / data.totalEpisodes) * 100;
        const lastEpisode = Math.max(...Array.from(data.watchedEpisodes));
        
        return `
          <div class="history-item">
            <div>
              <div class="history-title">${data.title}</div>
              <div class="history-progress">Episode ${lastEpisode} of ${data.totalEpisodes}</div>
              <div class="progress-bar">
                <div class="progress-fill" style="width: ${progressPercent}%"></div>
              </div>
            </div>
            <button class="btn-standard secondary" style="padding: 6px 12px; font-size: 11px;" 
                    onclick="continueWatching('${slug}', ${lastEpisode + 1})">
              Continue
            </button>
          </div>
        `;
      }).join('');
    }

    function continueWatching(slug, nextEpisode) {
      const episodeUrl = `https://animekai.ac/watch/${slug}#ep=${nextEpisode}`;
      
      if (currentRoom && socket) {
        socket.emit("addVideo", { roomId: currentRoom, videoUrl: episodeUrl });
        const animeData = watchHistory[slug];
        showNotification(`Added: ${animeData.title} - Episode ${nextEpisode}`, "success");
        
        // Update history
        addToWatchHistory(slug, animeData.title, nextEpisode, animeData.totalEpisodes);
      }
      
      // Hide history panel
      document.getElementById("historyPanel").classList.remove('active');
    }

    // Anime Master-Slave Sync System
    function initializeAnimeMasterSync() {
      if (!isAnimeMode) return;
      
      animeSyncState.isMaster = syncState.isSyncMaster;
      animeSyncState.episodeStartTime = Date.now();
      animeSyncState.currentTime = 0;
      animeSyncState.isPaused = false;
      
      if (animeSyncState.isMaster) {
        console.log('Initialized as anime sync master');
        startAnimeMasterTracking();
      } else {
        console.log('Initialized as anime sync slave');
      }
    }

    function startAnimeMasterTracking() {
      if (!animeSyncState.isMaster || !isAnimeMode) return;
      
      // Track estimated playback time (for master)
      setInterval(() => {
        if (!animeSyncState.isPaused && isAnimeMode) {
          const elapsed = (Date.now() - animeSyncState.episodeStartTime) / 1000;
          animeSyncState.currentTime = elapsed;
        }
      }, 1000);
    }

    function sendAnimeSyncCommand(command, value = null) {
      if (!currentRoom || !isAnimeMode) return;
      
      // Show helpful notifications instead of fake commands
      switch(command) {
        case 'pause':
          showNotification("â¸ï¸ Please pause the video manually", "info", 3000);
          break;
        case 'play':
          showNotification("â–¶ï¸ Please play the video manually", "info", 3000);
          break;
        case 'sync':
          showNotification("ðŸ”„ Please check your video timing and adjust manually", "info", 4000);
          break;
        default:
          showNotification(`Please ${command} the video manually`, "info", 3000);
      }
    }

    function executeAnimeSyncCommand(command, value, slaveUser) {
      if (!animeSyncState.isMaster || !isAnimeMode) return;
      
      console.log(`Executing command from ${slaveUser}: ${command}`, value);
      
      let success = true;
      
      try {
        switch(command) {
          case 'pause':
            animeSyncState.isPaused = true;
            showNotification(`Paused by ${slaveUser}`, "info");
            break;
            
          case 'play':
            if (animeSyncState.isPaused) {
              animeSyncState.isPaused = false;
              animeSyncState.episodeStartTime = Date.now() - (animeSyncState.currentTime * 1000);
              showNotification(`Resumed by ${slaveUser}`, "info");
            }
            break;
            
          case 'seek':
            animeSyncState.currentTime = value;
            animeSyncState.episodeStartTime = Date.now() - (value * 1000);
            showNotification(`Seeked to ${Math.floor(value)}s by ${slaveUser}`, "info");
            break;
            
          case 'sync':
            showNotification(`Sync check requested by ${slaveUser}`, "info");
            break;
            
          default:
            success = false;
        }
      } catch (error) {
        console.error('Error executing anime sync command:', error);
        success = false;
      }
      
      // Confirm command execution
      socket.emit("animeSyncCommandExecuted", {
        roomId: currentRoom,
        command: command,
        success: success,
        timestamp: Date.now()
      });
    }

    function updateAnimeSyncStatus(masterState) {
      if (animeSyncState.isMaster || !isAnimeMode) return;
      
      animeSyncState.masterState = masterState;
      
      // Calculate estimated local time
      const elapsed = (Date.now() - animeSyncState.episodeStartTime) / 1000;
      const timeDifference = Math.abs(elapsed - masterState.currentTime);
      
      // Update sync offset
      animeSyncState.syncOffset = masterState.currentTime - elapsed;
      
      // Update sync indicator based on difference
      let syncStatus = 'In Sync';
      let className = 'sync-indicator';
      
      if (timeDifference > 5) {
        syncStatus = 'Out of Sync';
        className += ' out-of-sync';
      } else if (timeDifference > 2) {
        syncStatus = 'Minor Desync';
        className += ' syncing';
      }
      
      const indicator = document.getElementById('syncIndicator');
      const statusText = document.getElementById('syncStatus');
      
      if (indicator && statusText) {
        indicator.className = className;
        statusText.textContent = `${syncStatus} (${Math.floor(masterState.currentTime)}s)`;
      }
    }

    function requestSeek() {
      const time = prompt("Enter time in seconds to seek to:");
      if (time && !isNaN(time)) {
        const timeValue = parseFloat(time);
        showNotification(`â­ï¸ Please seek to ${Math.floor(timeValue)}s manually`, "info", 4000);
      }
    }

    // Sync assistance functions (keep for compatibility)
    function respondToSyncCheck(isInSync) {
      if (!syncCheckActive || !currentRoom || !socket) return;
      
      socket.emit("animeSyncResponse", {
        roomId: currentRoom,
        timestamp: Date.now(),
        isInSync: isInSync
      });
      
      document.getElementById("syncHelper").classList.remove('active');
      syncCheckActive = false;
      
      if (isInSync) {
        showNotification("Sync response sent: In sync", "success");
      } else {
        showNotification("Sync response sent: Need resync", "warning");
      }
    }

    // Settings management
    function updateRoomSettings() {
      if (!currentRoom || !socket || !isCurrentUserAdmin()) return;
      
      socket.emit("updateRoomSettings", {
        roomId: currentRoom,
        settings: {
          animeSettings: roomSettings
        }
      });
    }

    function toggleSetting(settingName) {
      roomSettings[settingName] = !roomSettings[settingName];
      
      // Update UI
      const toggle = document.getElementById(settingName + 'Toggle');
      if (toggle) {
        toggle.classList.toggle('active', roomSettings[settingName]);
      }
      
      // Update server if admin
      if (isCurrentUserAdmin()) {
        updateRoomSettings();
      }
      
      console.log(`Setting ${settingName} toggled to:`, roomSettings[settingName]);
    }

    // Keep original YouTube search functionality
    async function searchVideos(query) {
      try {
        console.log("Searching for:", query);
        
        const searchBtn = document.getElementById("searchBtn");
        const originalText = searchBtn.textContent;
        searchBtn.textContent = "Searching...";
        searchBtn.disabled = true;
        
        document.getElementById("searchResults").innerHTML = `
          <div style="padding: 20px; text-align: center; color: #888;">
            <p>Searching for "${query}"...</p>
          </div>
        `;
        document.getElementById("searchResults").style.display = "block";
        
        const response = await fetch(`${SERVER_URL}/api/search?q=${encodeURIComponent(query)}`);
        const data = await response.json();
        
        console.log("Search response:", data);
        
        if (response.ok && data.videos && data.videos.length > 0) {
          displaySearchResults(data.videos);
          showNotification(`Found ${data.videos.length} videos`, "success");
        } else {
          console.error("Search failed:", data);
          showNotification(data.error || "No videos found", "warning");
          document.getElementById("searchResults").innerHTML = `
            <div style="padding: 20px; text-align: center; color: #888;">
              <p>No videos found for "${query}"</p>
              <p style="font-size: 12px;">Try a different search term</p>
              ${data.details ? `<p style="font-size: 11px; color: #666; margin-top: 10px;">Error: ${data.details}</p>` : ''}
            </div>
          `;
          document.getElementById("searchResults").style.display = "block";
        }
        
        searchBtn.textContent = originalText;
        searchBtn.disabled = false;
        
      } catch (error) {
        console.error("Search error:", error);
        showNotification("Search failed - check connection", "error");
        
        const searchBtn = document.getElementById("searchBtn");
        searchBtn.textContent = "Search";
        searchBtn.disabled = false;
      }
    }

    function displaySearchResults(videos) {
      const resultsContainer = document.getElementById("searchResults");
      resultsContainer.innerHTML = videos.map(video => `
        <div class="search-item" onclick="addSearchResult('${video.id}', '${video.title.replace(/'/g, "\\'")}')">
          <img src="${video.thumbnail}" alt="${video.title}" class="search-thumbnail">
          <div class="search-info">
            <div class="search-title">${video.title}</div>
            <div class="search-channel">${video.channelTitle}</div>
          </div>
        </div>
      `).join('');
      resultsContainer.style.display = 'block';
    }

    function addSearchResult(videoId, title) {
      const videoUrl = `https://youtube.com/watch?v=${videoId}`;
      
      if (currentRoom && socket) {
        console.log("Adding video from search:", videoUrl);
        socket.emit("addVideo", { roomId: currentRoom, videoUrl: videoUrl });
        showNotification(`Added: ${title}`, "success");
      } else {
        document.getElementById("videoInput").value = videoUrl;
        showNotification(`Selected: ${title}`, "info");
      }
      
      document.getElementById("searchResults").style.display = 'none';
      document.getElementById("searchInput").value = '';
    }

    function generateInviteLink() {
      if (!currentRoom) {
        showNotification("You must be in a room to generate an invite", "error");
        return;
      }
      
      const inviteUrl = `${window.location.origin}/invite/${currentRoom}`;
      
      navigator.clipboard.writeText(inviteUrl).then(() => {
        showNotification("Invite link copied to clipboard!", "success");
      }).catch(() => {
        const textArea = document.createElement("textarea");
        textArea.value = inviteUrl;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        showNotification("Invite link copied to clipboard!", "success");
      });
    }

    function checkInviteRoom() {
      const urlParams = new URLSearchParams(window.location.search);
      const roomParam = urlParams.get('room');
      const errorParam = urlParams.get('error');
      
      if (errorParam === 'room_not_found') {
        showNotification("Room not found or no longer active", "error");
      }
      
      if (roomParam) {
        document.getElementById("roomInput").value = roomParam;
        showNotification("Room loaded from invite link", "info");
      }
    }

    function isCurrentUserAdmin() {
      return currentUserData && currentUserData.isAdmin;
    }

    function getCurrentUserFromList(users) {
      const currentName = document.getElementById("nameInput").value;
      return users.find(user => user.name === currentName);
    }

    function removeFromQueue(queueIndex) {
      if (currentRoom && socket) {
        console.log("Removing video from queue at index:", queueIndex);
        socket.emit("removeFromQueue", { roomId: currentRoom, queueIndex: queueIndex });
        showNotification("Video removed from queue", "info");
      }
    }

    function setupSocketListeners() {
      socket.on("roomStatus", (data) => {
        const name = document.getElementById("nameInput").value.trim();
        const room = document.getElementById("roomInput").value.trim();
        
        if (data.exists) {
          if (data.hasPassword) {
            document.getElementById("loginTitle").textContent = "Enter Password";
            document.getElementById("passwordSection").style.display = "block";
            document.getElementById("createPasswordSection").style.display = "none";
            document.getElementById("joinBtn").textContent = "Join Room";
            document.getElementById("createRoomBtn").style.display = "none";
            document.getElementById("joinBtn").onclick = () => {
              const password = document.getElementById("passwordInput").value.trim();
              socket.emit("joinRoom", { roomId: room, userName: name, password: password });
            };
          } else {
            socket.emit("joinRoom", { roomId: room, userName: name, password: null });
          }
        } else {
          document.getElementById("loginTitle").textContent = "Create Room";
          document.getElementById("passwordSection").style.display = "none";
          document.getElementById("createPasswordSection").style.display = "block";
          document.getElementById("joinBtn").style.display = "none";
          document.getElementById("createRoomBtn").style.display = "block";
        }
      });

      socket.on("roomJoined", (data) => {
        console.log("Successfully joined room:", data);
        currentRoom = data.roomId;
        showNotification(`${data.isCreator ? 'Created' : 'Joined'} room: ${data.roomId}`, "success");
        document.getElementById("loginSection").style.display = "none";
        document.getElementById("appSection").style.display = "block";
        
        // Initialize sync system
        initializeSyncSystem();
        
        // Reset UI state for new room
        document.getElementById("skipVoteStatus").style.display = "none";
        document.getElementById("kickVoteStatus").style.display = "none";
        hasVotedSkip = false;
        currentSkipVotes = { votes: 0, total: 0 };
        currentKickVotes = {};
        
        const readyBtn = document.getElementById("readyBtn");
        readyBtn.textContent = "Ready";
        readyBtn.className = "btn-standard ready";
        isReady = false;
      });

      socket.on("roomError", (message) => {
        showNotification(message, "error");
        document.getElementById("passwordInput").value = "";
        document.getElementById("createPasswordInput").value = "";
      });

      socket.on("updateQueue", (data) => {
        const queue = data.queue || data;
        const videoInfoCache = data.videoInfoCache || {};
        
        console.log("Queue updated:", queue, "Video info cache:", videoInfoCache);
        const queueList = document.getElementById("queueList");
        if (queue.length === 0) {
          queueList.innerHTML = `
            <div class="empty-state">
              <svg viewBox="0 0 24 24" fill="currentColor">
                <path d="M15,6H3V8H15V6M15,10H3V12H15V10M3,16H11V14H3V16M17,6V14.5L22,9.5L17,6Z" />
              </svg>
              <p>Queue is empty</p>
            </div>`;
        } else {
          queueList.innerHTML = queue.map((videoId, index) => {
            const videoInfo = videoInfoCache[videoId];
            const title = videoInfo ? videoInfo.title : `https://youtube.com/watch?v=${videoId}`;
            const channel = videoInfo ? ` by ${videoInfo.channelTitle}` : '';
            
            return `
              <div class="queue-item">
                <div class="queue-number">${index + 1}</div>
                <div class="queue-title" style="flex: 1;">
                  <div style="font-weight: 500;">${title}</div>
                  ${channel ? `<div style="font-size: 12px; color: #888; margin-top: 2px;">${channel}</div>` : ''}
                </div>
                <button class="remove-btn" onclick="removeFromQueue(${index})" title="Remove from queue">Remove</button>
              </div>
            `;
          }).join('');
        }
      });

      socket.on("updateUsers", (users) => {
        console.log("Users updated:", users);
        const userList = document.getElementById("userList");
        
        if (!users || users.length === 0) {
          userList.innerHTML = '<div style="color: #888; text-align: center; padding: 10px;">No users in room</div>';
          return;
        }
        
        userList.innerHTML = "";
        currentUsers.clear();
        
        let readyCount = 0;
        users.forEach((user, index) => {
          const userId = `user_${index}_${user.name}`;
          currentUsers.set(user.name, userId);
          
          const currentUserName = document.getElementById("nameInput").value;
          if (user.name === currentUserName) {
            currentUserData = user;
            // Update sync master status based on user data
            updateSyncMasterStatus(user.isSyncMaster || false);
          }
          
          const userDiv = document.createElement("div");
          userDiv.className = "user" + (user.ready ? " ready" : "") + (user.isSyncMaster ? " sync-master" : "");
          userDiv.style.display = "flex";
          userDiv.style.alignItems = "center";
          userDiv.style.justifyContent = "space-between";
          userDiv.style.width = "100%";
          userDiv.style.padding = "8px 12px";
          userDiv.style.marginBottom = "5px";
          userDiv.style.borderRadius = "8px";
          
          userDiv.innerHTML = `
            <div style="display: flex; align-items: center; gap: 8px;">
              <div class="user-status"></div>
              <span>${user.name}</span>
              ${user.isAdmin ? '<span class="admin-icon" title="Room Admin">ADMIN</span>' : ''}
              ${user.isSyncMaster ? '<span class="sync-master-icon" title="Sync Master">SYNC</span>' : ''}
            </div>
            <div class="user-actions">
              ${user.isAdmin ? '' : `<button class="kick-btn" onclick="kickUser('${userId}', '${user.name}')" title="Kick ${user.name}" ${!isCurrentUserAdmin() ? 'style="display:none"' : ''}>Kick</button>`}
            </div>
          `;
          userList.appendChild(userDiv);
          if (user.ready) readyCount++;
        });
        
        console.log(`Displayed ${users.length} users, ${readyCount} ready`);

        const readyStatus = document.getElementById("readyStatus");
        let statusHTML = `<strong>${readyCount}/${users.length}</strong> users ready`;
        
        if (currentSkipVotes.votes > 0) {
          const skipPercent = (currentSkipVotes.votes / currentSkipVotes.total) * 100;
          statusHTML += `
            <div class="vote-progress">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                <span style="font-size: 12px; color: #ff6b6b;">Skip Vote Progress</span>
                <span style="font-size: 12px;">${currentSkipVotes.votes}/${currentSkipVotes.total}</span>
              </div>
              <div class="vote-bar">
                <div class="vote-progress-fill" style="width: ${skipPercent}%;"></div>
              </div>
            </div>
          `;
        }
        
        Object.entries(currentKickVotes).forEach(([targetUser, voteData]) => {
          if (voteData.votes > 0) {
            const kickPercent = (voteData.votes / voteData.required) * 100;
            statusHTML += `
              <div class="vote-progress">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                  <span style="font-size: 12px; color: #ffa500;">Kick ${targetUser}</span>
                  <span style="font-size: 12px;">${voteData.votes}/${voteData.required}</span>
                </div>
                <div class="vote-bar">
                  <div class="vote-progress-fill" style="width: ${kickPercent}%; background: linear-gradient(90deg, #ffa500, #ff6348);"></div>
                </div>
              </div>
            `;
          }
        });
        
        readyStatus.innerHTML = statusHTML;
      });

      socket.on("playVideo", (data) => {
        console.log("Play video:", data);
        updateVideoTitle(data.videoId, data.videoInfo);
        
        const platform = data.platform || 'youtube';
        
        if (platform === 'youtube' && player) {
          player.loadVideoById(data.videoId);
          setTimeout(() => {
            if (data.isPaused) {
              player.pauseVideo();
            }
            if (data.currentTime > 0) {
              player.seekTo(data.currentTime, true);
            }
          }, 1000);
        } else if (platform === 'anime') {
          createPlayer(data.videoId, platform, {
            episode: data.episode,
            embedUrl: data.embedUrl,
            ...data.videoInfo
          });
          
          // Add to watch history if enabled
          if (roomSettings.watchHistory && data.videoInfo) {
            addToWatchHistory(
              data.videoId, 
              data.videoInfo.animeTitle || data.videoInfo.title, 
              parseInt(data.episode) || 1,
              data.videoInfo.totalEpisodes || 12
            );
          }
        } else {
          createPlayer(data.videoId, platform);
        }
        
        hasVotedSkip = false;
        const skipBtn = document.getElementById("skipBtn");
        skipBtn.textContent = "Vote Skip";
        skipBtn.className = "btn-standard secondary";
        document.getElementById("skipVoteStatus").style.display = "none";
        document.getElementById("kickVoteStatus").style.display = "none";
      });

      // Enhanced sync event handlers
      socket.on("syncHeartbeat", handleSyncHeartbeat);
      
      socket.on("syncMasterChanged", (data) => {
        console.log("Sync master changed:", data);
        if (data.isSyncMaster !== undefined) {
          updateSyncMasterStatus(data.isSyncMaster);
        }
      });

      socket.on("syncResponse", (data) => {
        console.log("Received sync response:", data);
        handleSyncHeartbeat(data);
      });

      // High-Precision Sync Handlers
      socket.on("precisionSync", (data) => {
        handlePrecisionSync(data);
      });

      socket.on("latencyPong", (data) => {
        handleLatencyMeasurement(data);
      });

      socket.on("syncRequest", (data) => {
        // Handle sync request from other users (if we're sync master)
        if (syncState.isSyncMaster && player) {
          const currentTime = player.getCurrentTime();
          const isPaused = player.getPlayerState() !== YT.PlayerState.PLAYING;
          
          socket.emit("syncResponse", {
            currentTime: currentTime,
            isPaused: isPaused,
            timestamp: Date.now()
          });
        }
      });

      // Regular event handlers continue...
      socket.on("videoAdded", (data) => {
        showNotification(`${data.user} added: ${data.videoInfo.title}`, "success");
      });

      socket.on("videoError", (data) => {
        showNotification(data.message, "error");
      });

      socket.on("kickError", (message) => {
        showNotification(message, "error");
      });

      socket.on("videoStopped", () => {
        console.log("Video stopped");
        if (player) {
          player.stopVideo();
        }
        updateVideoTitle(null);
      });

      socket.on("syncPause", (currentTime) => {
        if (isAnimeMode) {
          // Can't control anime player directly
          showNotification("Anime paused - manual sync may be needed", "info");
          return;
        }
        
        if (player && !syncState.preventSync && !syncState.isSyncMaster) {
          syncState.preventSync = true;
          player.seekTo(currentTime, true);
          player.pauseVideo();
          setTimeout(() => { syncState.preventSync = false; }, 1000);
        }
      });

      socket.on("syncPlay", (currentTime) => {
        if (isAnimeMode) {
          // Can't control anime player directly
          showNotification("Anime resumed - manual sync may be needed", "info");
          return;
        }
        
        if (player && !syncState.preventSync && !syncState.isSyncMaster) {
          syncState.preventSync = true;
          player.seekTo(currentTime, true);
          player.playVideo();
          setTimeout(() => { syncState.preventSync = false; }, 1000);
        }
      });

      socket.on("syncSeek", (currentTime) => {
        if (isAnimeMode) {
          // Can't control anime player directly
          showNotification(`Seek to ${Math.floor(currentTime)}s - please sync manually`, "info");
          return;
        }
        
        if (player && !syncState.preventSync && !syncState.isSyncMaster) {
          syncState.preventSync = true;
          player.seekTo(currentTime, true);
          setTimeout(() => { syncState.preventSync = false; }, 1000);
        }
      });

      socket.on("syncTime", (data) => {
        console.log("Syncing time for new user:", data);
        if (player && player.seekTo) {
          syncState.preventSync = true;
          player.seekTo(data.currentTime, true);
          if (data.isPaused) {
            player.pauseVideo();
          } else {
            player.playVideo();
          }
          setTimeout(() => { syncState.preventSync = false; }, 1500);
        }
      });

      socket.on("allReady", () => {
        showNotification("All users ready! Starting video...", "success");
      });

      socket.on("skipVoteUpdate", (data) => {
        console.log("Skip vote update:", data);
        
        currentSkipVotes = { votes: data.votes, total: data.total };
        
        const skipStatus = document.getElementById("skipVoteStatus");
        
        if (data.votes > 0) {
          skipStatus.style.display = "block";
          skipStatus.innerHTML = `
            <strong>Skip Vote:</strong> ${data.votes}/${data.total} votes<br>
            <small>${data.user} ${data.action} their vote</small>
          `;
        } else {
          skipStatus.style.display = "none";
        }
        
        if (data.action === "added") {
          showNotification(`${data.user} voted to skip (${data.votes}/${data.total})`, "warning");
        } else {
          showNotification(`${data.user} removed their skip vote (${data.votes}/${data.total})`, "info");
        }
      });

      socket.on("videoSkipped", (data) => {
        showNotification("Video skipped by vote!", "warning");
        document.getElementById("skipVoteStatus").style.display = "none";
        currentSkipVotes = { votes: 0, total: 0 };
      });

      socket.on("userKicked", (data) => {
        const kickMessage = data.reason === "admin" && data.kickedBy 
          ? `${data.user} was kicked by admin ${data.kickedBy}` 
          : `${data.user} was kicked from the room`;
        showNotification(kickMessage, "warning");
        document.getElementById("kickVoteStatus").style.display = "none";
        userKickVotes.clear();
        delete currentKickVotes[data.user];
      });

      socket.on("kicked", (data) => {
        isLeavingRoom = true;
        showNotification(`You were kicked from room ${data.room}`, "error");
        document.getElementById("appSection").style.display = "none";
        document.getElementById("loginSection").style.display = "block";
        socket = null;
      });

      socket.on("userJoined", (data) => {
        showNotification(`${data.userName} joined the room`, "success");
      });

      socket.on("userLeft", (data) => {
        showNotification(`${data.userName} left the room`, "info");
      });

      socket.on("videoRemoved", (data) => {
        showNotification(`${data.user} removed: ${data.videoInfo.title}`, "warning");
      });

      // Enhanced anime event handlers
      socket.on("autoProgression", (data) => {
        showNotification(`Auto-progression: ${data.nextEpisode}`, "success");
        console.log("Auto progression:", data);
      });

      socket.on("animeSyncStart", (data) => {
        console.log("Anime sync assistance started:", data);
        if (isAnimeMode) {
          showNotification("Anime sync: " + data.message, "info");
        }
      });

      socket.on("animeSyncCheck", (data) => {
        if (!isAnimeMode) return;
        
        console.log("Anime sync check requested:", data);
        syncCheckActive = true;
        
        document.getElementById("syncHelperMessage").textContent = data.message;
        document.getElementById("syncHelper").classList.add('active');
        
        // Auto-hide after 30 seconds
        setTimeout(() => {
          if (syncCheckActive) {
            document.getElementById("syncHelper").classList.remove('active');
            syncCheckActive = false;
          }
        }, 30000);
      });

      socket.on("animeSyncResult", (data) => {
        console.log("Anime sync result:", data);
        showNotification(data.message, data.type);
        
        // Hide sync helper
        document.getElementById("syncHelper").classList.remove('active');
        syncCheckActive = false;
      });

      socket.on("roomSettings", (data) => {
        console.log("Room settings received:", data);
        if (data.animeSettings) {
          Object.assign(roomSettings, data.animeSettings);
          updateSettingsUI();
        }
      });

      socket.on("roomSettingsUpdated", (data) => {
        console.log("Room settings updated:", data);
        if (data.animeSettings) {
          Object.assign(roomSettings, data.animeSettings);
          updateSettingsUI();
          showNotification("Room settings updated", "success");
        }
      });

      socket.on("settingsError", (message) => {
        showNotification(message, "error");
      });

      // Enhanced Anime Master-Slave Sync System
      socket.on("requestAnimeSyncState", (data) => {
        if (!animeSyncState.isMaster || !isAnimeMode) return;
        
        // Send current anime state to server
        socket.emit("animeSyncState", {
          roomId: data.roomId,
          currentTime: animeSyncState.currentTime,
          isPaused: animeSyncState.isPaused,
          playbackRate: 1.0,
          timestamp: data.timestamp
        });
      });

      socket.on("animeSyncUpdate", (data) => {
        if (animeSyncState.isMaster || !isAnimeMode) return;
        
        // Update sync status based on master state
        updateAnimeSyncStatus(data);
        console.log('Received anime sync update:', data);
      });

      socket.on("animeSyncCommandFromSlave", (data) => {
        if (!animeSyncState.isMaster || !isAnimeMode) return;
        
        // Execute command from slave
        executeAnimeSyncCommand(data.command, data.value, data.slaveUser);
      });

      socket.on("animeSyncCommandNotification", (data) => {
        console.log('Anime sync command notification:', data.message);
        showNotification(data.message, "info");
      });

      socket.on("animeSyncCommandResult", (data) => {
        const type = data.success ? "success" : "warning";
        showNotification(data.message, type);
      });
    }

    // Button Event Handlers
    document.getElementById("addVideoBtn").onclick = () => {
      const url = document.getElementById("videoInput").value.trim();
      if (!url) {
        showNotification("Please enter a video URL", "error");
        return;
      }
      
      console.log("Adding video:", url);
      socket.emit("addVideo", { roomId: currentRoom, videoUrl: url });
      document.getElementById("videoInput").value = "";
      document.getElementById("searchResults").style.display = "none";
      showNotification("Video added to queue", "success");
    };

    document.getElementById("searchBtn").onclick = () => {
      const query = document.getElementById("searchInput").value.trim();
      if (!query) {
        showNotification("Please enter a search term", "error");
        return;
      }
      searchVideos(query);
    };

    // New anime search button
    document.getElementById("animeSearchBtn").onclick = () => {
      animeSearchActive = !animeSearchActive;
      const container = document.getElementById("animeSearchContainer");
      
      if (animeSearchActive) {
        container.classList.add('active');
        if (currentAnimeTab === 'popular') {
          searchAnime(); // Load popular anime
        }
        // Hide regular search results
        document.getElementById("searchResults").style.display = "none";
      } else {
        container.classList.remove('active');
      }
    };

    // Settings button
    document.getElementById("settingsBtn").onclick = () => {
      const panel = document.getElementById("settingsPanel");
      const isActive = panel.classList.contains('active');
      
      // Hide other panels
      document.getElementById("historyPanel").classList.remove('active');
      
      if (isActive) {
        panel.classList.remove('active');
      } else {
        panel.classList.add('active');
        // Request room settings from server
        if (socket && currentRoom) {
          socket.emit("getRoomSettings", currentRoom);
        }
      }
    };

    // History button
    document.getElementById("historyBtn").onclick = () => {
      const panel = document.getElementById("historyPanel");
      const isActive = panel.classList.contains('active');
      
      // Hide other panels
      document.getElementById("settingsPanel").classList.remove('active');
      
      if (isActive) {
        panel.classList.remove('active');
      } else {
        panel.classList.add('active');
        displayWatchHistory();
      }
    };

    document.getElementById("inviteBtn").onclick = generateInviteLink;

    document.getElementById("skipBtn").onclick = () => {
      if (currentRoom && socket) {
        console.log("Voting to skip");
        socket.emit("voteSkip", currentRoom);
        
        hasVotedSkip = !hasVotedSkip;
        const btn = document.getElementById("skipBtn");
        if (hasVotedSkip) {
          btn.textContent = "Remove Vote";
          btn.className = "btn-standard danger";
          showNotification("Vote added", "info");
        } else {
          btn.textContent = "Vote Skip";
          btn.className = "btn-standard secondary";
          showNotification("Vote removed", "info");
        }
      }
    };

    document.getElementById("readyBtn").onclick = () => {
      if (currentRoom && socket) {
        console.log("Toggling ready state");
        isReady = !isReady;
        socket.emit("toggleReady", currentRoom);
        const btn = document.getElementById("readyBtn");
        if (isReady) {
          btn.textContent = "Not Ready";
          btn.className = "btn-standard danger";
          showNotification("You are now ready!", "success");
        } else {
          btn.textContent = "Ready";
          btn.className = "btn-standard ready";
          showNotification("You are no longer ready", "info");
        }
      }
    };

    function createPlayer(videoId, platform = 'youtube', extraData = {}) {
      const container = document.getElementById('videoContainer');
      container.innerHTML = '';
      currentPlatform = platform;
      
      if (platform === 'youtube') {
        isAnimeMode = false;
        document.getElementById('animeSyncWarning').style.display = 'none';
        
        player = new YT.Player('videoContainer', {
          height: '100%',
          width: '100%',
          videoId: videoId,
          playerVars: {
            'autoplay': 1,
            'modestbranding': 1,
            'rel': 0,
            'showinfo': 0,
            'controls': 1,
            'enablejsapi': 1
          },
          events: { 
            'onStateChange': onPlayerStateChange,
            'onReady': onPlayerReady
          }
        });
      } else if (platform === 'anime') {
        isAnimeMode = true;
        document.getElementById('animeSyncWarning').style.display = 'block';
        
        // Use the exact embedUrl provided, or fall back to a default pattern
        const embedUrl = extraData.embedUrl || `https://hianime.to/watch/${videoId}`;
        
        // Determine if user is sync master for anime controls
        const isSyncMaster = syncState.isSyncMaster;
        const syncControlsClass = isSyncMaster ? '' : 'active';
        
        container.innerHTML = `
          <iframe 
            src="${embedUrl}" 
            width="100%" 
            height="100%" 
            frameborder="0" 
            allowfullscreen
            allow="autoplay; fullscreen"
            style="border-radius: 15px;">
          </iframe>
          <div class="anime-overlay">
            Episode ${extraData.episode || 1}
          </div>
          ${isSyncMaster ? '<div class="master-indicator">You are the Sync Master</div>' : ''}
          <div class="anime-sync-controls ${syncControlsClass}" id="animeSyncControls">
            <button class="anime-sync-btn" onclick="sendAnimeSyncCommand('pause')">Pause</button>
            <button class="anime-sync-btn" onclick="sendAnimeSyncCommand('play')">Play</button>
            <button class="anime-sync-btn" onclick="requestSeek()">Seek</button>
            <button class="anime-sync-btn" onclick="sendAnimeSyncCommand('sync')">Sync</button>
          </div>
        `;
        
        // Initialize anime sync system
        setTimeout(() => {
          initializeAnimeMasterSync();
        }, 1000);
        
      } else if (platform === 'vimeo') {
        isAnimeMode = false;
        document.getElementById('animeSyncWarning').style.display = 'none';
        
        container.innerHTML = `<iframe src="https://player.vimeo.com/video/${videoId}?autoplay=1" width="100%" height="100%" frameborder="0" allow="autoplay; fullscreen; picture-in-picture"></iframe>`;
      } else if (platform === 'twitch') {
        isAnimeMode = false;
        document.getElementById('animeSyncWarning').style.display = 'none';
        
        container.innerHTML = `<iframe src="https://player.twitch.tv/?video=${videoId}&parent=${window.location.hostname}&autoplay=true" width="100%" height="100%" frameborder="0"></iframe>`;
    }

    function onPlayerReady(event) {
      console.log("YouTube player ready");
      const iframe = event.target.getIframe();
      iframe.style.aspectRatio = '16/9';
      iframe.style.width = '100%';
      iframe.style.height = 'auto';
      
      // Initialize sync state
      syncState.lastKnownTime = 0;
      syncState.isInSync = true;
      updateSyncIndicator();
    }

    function onPlayerStateChange(event) {
      if (syncState.preventSync || isLeavingRoom || isAnimeMode) return;
      
      if (!socket || !socket.connected || !currentRoom) return;

      // Only sync masters broadcast state changes to reduce conflicts
      if (!syncState.isSyncMaster) return;

      const now = Date.now();
      if (now - syncState.lastSyncBroadcast < syncState.syncCooldown) return;

      if (event.data === YT.PlayerState.ENDED) {
        console.log("Video ended");
        socket.emit("videoEnded", currentRoom);
      } else if (event.data === YT.PlayerState.PAUSED) {
        const currentTime = player.getCurrentTime();
        console.log("Video paused at", currentTime);
        socket.emit("pauseVideo", { roomId: currentRoom, currentTime });
        syncState.lastSyncBroadcast = now;
      } else if (event.data === YT.PlayerState.PLAYING) {
        const currentTime = player.getCurrentTime();
        console.log("Video playing at", currentTime);
        socket.emit("playVideo", { roomId: currentRoom, currentTime });
        syncState.lastSyncBroadcast = now;
      }
    }

    // Enhanced keyboard handling
    document.getElementById("nameInput").addEventListener("keypress", (e) => {
      if (e.key === "Enter") document.getElementById("roomInput").focus();
    });
    
    document.getElementById("roomInput").addEventListener("keypress", (e) => {
      if (e.key === "Enter") document.getElementById("joinBtn").click();
    });
    
    document.getElementById("videoInput").addEventListener("keypress", (e) => {
      if (e.key === "Enter") document.getElementById("addVideoBtn").click();
    });
    
    document.getElementById("searchInput").addEventListener("keypress", (e) => {
      if (e.key === "Enter") document.getElementById("searchBtn").click();
    });

    // Add focus event to show anime URL examples
    document.getElementById("videoInput").addEventListener("focus", (e) => {
      if (!e.target.value) {
        e.target.placeholder = "Try: https://animekai.ac/watch/demon-slayer-season-4-abc1#ep=1";
      }
    });

    document.getElementById("videoInput").addEventListener("blur", (e) => {
      if (!e.target.value) {
        e.target.placeholder = "Paste YouTube, AnimeKai, Vimeo, or Twitch URL";
      }
    });
    
    // Enhanced page visibility handling
    document.addEventListener('visibilitychange', () => {
      if (!document.hidden && currentRoom && socket && socket.connected) {
        // When tab becomes active, request sync to ensure we're still in sync
        setTimeout(() => {
          if (!syncState.isSyncMaster) {
            requestSync();
          }
        }, 1000);
      }
    });

    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
      isLeavingRoom = true;
      if (syncState.syncCheckInterval) clearInterval(syncState.syncCheckInterval);
      if (syncState.heartbeatInterval) clearInterval(syncState.heartbeatInterval);
    });

    // Hide search results when clicking outside
    document.addEventListener("click", (e) => {
      const searchContainer = document.querySelector(".search-container");
      if (!searchContainer.contains(e.target)) {
        document.getElementById("searchResults").style.display = "none";
      }
    });

    // Initialize on page load
    window.addEventListener('load', () => {
      checkInviteRoom();
      loadStats();
      loadWatchHistory();
      
      // Setup anime search tabs
      document.querySelectorAll('.anime-tab').forEach(tab => {
        tab.addEventListener('click', (e) => {
          const tabName = e.target.dataset.tab;
          
          // Update active tab
          document.querySelectorAll('.anime-tab').forEach(t => t.classList.remove('active'));
          e.target.classList.add('active');
          
          currentAnimeTab = tabName;
          
          if (tabName === 'popular') {
            document.getElementById('animeSearchInput').style.display = 'none';
            searchAnime(); // Load popular
          } else if (tabName === 'search') {
            document.getElementById('animeSearchInput').style.display = 'block';
          }
        });
      });
      
      // Setup anime search input
      document.getElementById('animeQuery').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          const query = e.target.value.trim();
          if (query) {
            searchAnime(query);
          }
        }
      });
      
      // Setup settings toggles
      document.getElementById('autoProgressionToggle').addEventListener('click', () => {
        toggleSetting('autoProgression');
      });
      
      document.getElementById('syncAssistanceToggle').addEventListener('click', () => {
        toggleSetting('syncAssistance');
      });
      
      document.getElementById('watchHistoryToggle').addEventListener('click', () => {
        toggleSetting('watchHistory');
      });
      
      // Refresh stats every 30 seconds
      setInterval(loadStats, 30000);
    });
      } // Close socket initialization block
      
      checkRoom(room, name);
    };

    // Helper function to update settings UI
    function updateSettingsUI() {
      document.getElementById('autoProgressionToggle').classList.toggle('active', roomSettings.autoProgression);
      document.getElementById('syncAssistanceToggle').classList.toggle('active', roomSettings.syncAssistance);
      document.getElementById('watchHistoryToggle').classList.toggle('active', roomSettings.watchHistory);
    }

    // Load and display current stats
    async function loadStats() {
      try {
        const response = await fetch(`${SERVER_URL}/api/stats`);
        const stats = await response.json();
        
        document.getElementById('totalUsers').textContent = stats.totalUsers || 0;
        document.getElementById('activeRooms').textContent = stats.activeRooms || 0;
      } catch (error) {
        console.log('Failed to load stats:', error);
        // Don't show error to user, just keep previous values
      }
    }
  </script>
</body>
</html>
